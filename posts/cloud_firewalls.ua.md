# Фаєрволи в Хмарі: Від pf до правил VPC — Зміна Ментальної Моделі

## Вступ

Раніше фаєрволи жили всередині операційної системи. Чи то був pf на FreeBSD, чи iptables на Linux, правила були вбудовані безпосередньо в хост.
Сьогодні центр тяжіння змістився.

У сучасних хмарних платформах перший фаєрвол, який зустрічає ваш пакет, знаходиться не на вашій VM.
Він знаходиться у віртуальному мережевому середовищі — повністю розподіленій системі, яка оцінює правила задовго до того, як трафік досягне вашого ядра.

Security groups, VPC firewalls, network policies — всі вони служать тій самій меті, що й `pf` або `iptables`, але спосіб їх роботи фундаментально відрізняється.
Вони stateless або stateful залежно від платформи, застосовуються на рівні гіпервізора або фабрики, і прив'язані до мережевого інтерфейсу, VM, проекту або навіть сервісу.

І ось важлива частина:

Коли ви переходите в хмару, неправильно налаштований фаєрвол на хості рідко є тим, що ламає вашу систему.
Неправильно налаштоване правило VPC — ось причина.

Ця стаття про з'єднання обох світів.

Ви побачите, як традиційні хостові фаєрволи співвідносяться — а іноді ні — з хмарними фаєрволами.
Ми пройдемося по Google Cloud Platform, AWS та Azure, щоб зрозуміти:

як пакети рухаються через віртуальні мережі,

де насправді застосовуються правила фаєрволу,

чим хмарні фаєрволи відрізняються від `pf`/`iptables` за філософією та гарантіями, і

чому дебагінг хмарного з'єднання часто означає повне ігнорування VM.

Тому що в хмарі фаєрвол — це не просто набір правил.
Це частина самої інфраструктури.

І якщо ви зрозумієте цю ментальну модель, ви будете діагностувати хмарні системи швидше, ніж більшість інженерів.

## Чим Хмарні Фаєрволи Відрізняються

Коли ви переходите з on-premise або "голого заліза" в хмару, одна річ стає зрозумілою дуже швидко:

Хмарний фаєрвол — це не просто `pf` або `iptables`, що працює десь в іншому місці.
Це частина самої інфраструктурної тканини — і це змінює все.

Традиційні хостові фаєрволи (`pf`, `iptables`) застосовують правила всередині ядра ОС, безпосередньо на мережевому стеку машини.
Хмарні фаєрволи застосовують правила до того, як трафік торкнеться вашої VM.

Цей зсув вводить кілька фундаментальних відмінностей у тому, як поводяться хмарні фаєрволи, як вони застосовуються і як ви діагностуєте проблеми.

### 1. Застосування Відбувається Поза VM

На фізичній машині:

* pf фільтрує пакети в ядрі FreeBSD

* iptables/nftables фільтрують пакети в ядрі Linux

У хмарі:

* GCP VPC firewalls

* AWS Security Groups

* Azure NSGs

…фільтрують пакети у віртуальному мережевому середовищі, часто реалізованій всередині гіпервізора або розподіленого мережевого рівня.

Результат:
* Ваша VM ніколи не бачить трафік, який блокує хмарний фаєрвол.
* Жодних логів, жодних SYN-пакетів, нічого.

Це джерело плутанини №1 для інженерів, які звикли до хостових фаєрволів.

### 2. Фаєрволи Застосовуються до NIC, а Не Інтерфейсів, Які Ви Налаштовуєте

У pf або iptables ви обираєте інтерфейс:
```
pf:   pass in on em0 proto tcp to port 22
iptables: ..... -i eth0 -p tcp --dport 22 -j ACCEPT
```

Хмарні фаєрволи прикріплюються до:

* мережевих інтерфейсів (AWS ENI)

* інстансів VM (GCP instance-level)

* підмереж або VPC (Azure NSG / GCP VPC)

* тегів або сервісних акаунтів (GCP)

Це означає, що фаєрвол не прив'язаний до пристрою ядра — він прив'язаний до ідентичності ресурсу.

Наприклад, у GCP ви можете написати:

```
Allow tcp:22
Source: service account = linux-admin@myproject.iam.gserviceaccount.com
```
Ви навіть не вказуєте ім'я VM або мережевий інтерфейс.
Ця абстракція потужна, але відрізняється від традиційних фаєрволів.

### 3. Більшість Хмарних Фаєрволів Stateful за Замовчуванням

pf є stateful.
iptables може бути stateful, але правила визначають це.
Хмарні фаєрволи?

Вони автоматично stateful — завжди.

* Якщо ви дозволяєте вихідний 443, вхідний зворотний трафік дозволяється автоматично.

* Якщо ви дозволяєте вхідний 22, вихідні зворотні пакети автоматично дозволяються.

Ви не пишете правила для "established" або "related" з'єднань.

Це спрощує політику, але також приховує поведінку.
Легко забути, що хмарні фаєрволи відстежують таблиці з'єднань за лаштунками.

### 4. Напрямок Трафіку Реверсивний Порівняно з Хостовими Фаєрволами

Хостові фаєрволи мислять термінами:

* вхідний трафік до інтерфейсу
* вихідний трафік від інтерфейсу

Хмарні фаєрволи мислять термінами:

* джерело → призначення
* ingress до VM / egress від VM

Наприклад, у GCP:

* “ingress” означає трафік, що входить у вашу VM звідки завгодно
* “egress” означає трафік, що виходить з вашої VM, до того як він досягне Інтернету

І оцінка правил окрема для кожного напрямку.

Цей поділ напрямків часто плутає інженерів, які припускають семантику хоста.

### 5. Хмарні Фаєрволи Застосовуються До Маршрутизації

У `pf`/`iptables` рішення маршрутизації відбуваються перед деякими етапами фаєрволу.

**У хмарах пакети фільтруються до того, як:**

* обробляється DHCP
* відбувається виявлення ARP/NDP
* оцінюються таблиці маршрутизації
* ядро вашої VM бачить що-небудь

**Це означає:**

> **Якщо хмарний фаєрвол блокує це → ядро VM не має уявлення, що трафік взагалі існував.**

Це змінює те, як ви усуваєте несправності з'єднання:

* tcpdump всередині VM не показує нічого
* логи не показують нічого
* лічильники sysctl не збільшуються

Більшість відмов хмарної мережі невидимі з точки зору ОС.

### 6. Політики Нормалізуються Глобально, А Не Per-Host

Правила `pf` належать одному хосту.
Правила `iptables` належать одному хосту.

**Хмарні фаєрволи належать:**

* Цілим мережам VPC (GCP)
* Підмережам (Azure)
* Прикріпленням ENI (AWS)
* Тегам ідентичності (GCP)
* Цілим проектам або групам ресурсів

**Це означає:**

* політики послідовні по всьому флоту
* немає "сніжинок" (унікальних серверів)
* ви можете захистити 1000 машин одним правилом

**Але це також означає:**

* одне неправильне правило може зламати цілі середовища
* усунення несправностей може вплинути на глобальний трафік, а не тільки на один вузол

### 7. Хмарні Фаєрволи Не Замінюють Хостові Фаєрволи — Вони Доповнюють Їх

Критичний зсув мислення:

> Хмарні фаєрволи контролюють north-south трафік (в/з VM).
> Хостові фаєрволи контролюють east-west трафік (всередині VM або між локальними програмами).

Вам часто все ще потрібні `pf` або `iptables` для:

* мікросегментації всередині VM
* ізоляції контейнерів
* rate limiting
* просунутого логування
* трюків з NAT або перенаправлення портів
* блокування трафіку localhost → localhost

Хмарні фаєрволи не є кінцем `pf` або `iptables` — вони просто йдуть раніше в ланцюжку.

### Чому Це Важливо

Перш ніж занурюватися в специфіку AWS, GCP або Azure, вам потрібна правильна ментальна модель:

Хмарні фаєрволи не поводяться як pf або iptables.
Вони перевизначають весь шлях пакету.

Як тільки ви зрозумієте це, хмарна мережа перестане здаватися магічною — і почне знову здаватися передбачуваною.


## Потік Пакетів у GCP, AWS та Azure — Що Насправді Відбувається До Того, Як Ваша VM Побачить Пакет

Кожна хмарна платформа говорить про "віртуальні мережі", але справжнє питання для інженерів таке:

Що відбувається з вхідним пакетом до того, як він досягне моєї VM?

У on-prem системах шлях простий:
```
NIC → Kernel → pf/iptables → Application
```

У хмарі цей шлях стає розподіленим конвеєром, керованим провайдером — не вашою VM.
І кожна платформа реалізує цей конвеєр по-різному.

Давайте розберемо, що насправді відбувається в Google Cloud (GCP), Amazon Web Services (AWS) та Microsoft Azure, фокусуючись на ключових рішеннях безпеки та маршрутизації по дорозі.

### 1. Google Cloud Platform (GCP)
*Застосування на рівні фабрики, глобальний VPC, передбачувана оцінка*

GCP має найчистішу і найпрозорішу модель потоку пакетів з усіх основних хмар.

**Вхідний (Ingress) Потік Пакетів — GCP**
```
Internet  
   ↓  
Google Frontend (якщо використовується LB)  
   ↓  
VPC Firewall (правила ingress оцінюються тут)  
   ↓  
Маршрутизація підмережі  
   ↓  
VM NIC (virtio)  
   ↓  
Guest OS (потім pf/iptables, якщо налаштовано)
```

**Ключові Моменти**

* Правила фаєрволу застосовуються до маршрутизації — це означає, що пакет може бути відхилений до того, як він дізнається підмережу VM.

* Оцінка фаєрволу є глобальною та розподіленою, не прив'язаною до фізичного хоста.

**Правила можуть націлюватися на:**

* IP діапазони

* теги

* сервісні акаунти (супер потужно)

**Вихідний (Egress) Потік Пакетів — GCP**
```
Guest OS  
   ↓  
VM NIC  
   ↓  
VPC Firewall (правила egress оцінюються тут)  
   ↓  
Маршрутизація / NAT  
   ↓  
Internet / інші VPC
```
Якщо ви дозволяєте вихідний 0.0.0.0/0, весь зворотний трафік автоматично дозволяється (stateful).

### 2. Amazon Web Services (AWS)
*Ingress контролюється Security Groups; межі підмереж забезпечуються NACLs*

AWS має два шари фаєрволінгу:

* **Security Groups (SG)** — stateful, прикріплені до ENI
* **Network ACLs (NACLs)** — stateless, прикріплені до підмереж

Ця подвійна модель складніша, але надзвичайно потужна при правильному використанні.

**Вхідний (Ingress) Потік Пакетів — AWS**
```
Internet  
   ↓  
AWS Edge (NAT, ALB/ELB якщо використовується)  
   ↓  
NACL (рівень підмережі, stateless)  
   ↓  
Security Group (рівень ENI, stateful)  
   ↓  
VM ENI  
   ↓  
Guest OS (iptables, nftables, pf для EC2 FreeBSD)
```

**Ключові Моменти**

* Якщо NACL відхиляє пакет → інстанс ніколи його не бачить.
* Якщо SG відхиляє пакет → інстанс ніколи його не бачить.
* Якщо SG дозволяє вхідний → вихідний зворотний автоматично дозволяється.
* Логіка SG проста; логіка NACL складна, тому що вона stateless і оцінюється по порядку.

**Вихідний (Egress) Потік Пакетів — AWS**
```
Guest OS  
   ↓  
ENI  
   ↓  
Security Group (stateful)  
   ↓  
NACL (stateless)  
   ↓  
Маршрутизація / NAT  
   ↓  
Public Internet або VPC peering
```
AWS — єдина хмара, де вихідний трафік може бути заблокований на двох рівнях.

### 3. Microsoft Azure
*Розподілені фаєрволи на кількох рівнях — NSG, ASG та правила платформи*

Azure використовує:

* **NSGs (Network Security Groups)** — основний фаєрвол
* **ASGs (Application Security Groups)** — логічне групування
* **Правила рівня платформи** — іноді неявні та незмінні
* **Маршрутизація рівня VNet** — впливає на порядок оцінки

Потік пакетів Azure найменш інтуїтивний, але все ще керований з правильною моделлю.

**Вхідний (Ingress) Потік Пакетів — Azure**
```
Internet  
   ↓  
Azure Load Balancer (якщо використовується)  
   ↓  
NSG (рівень підмережі)  
   ↓  
NSG (рівень NIC)  
   ↓  
VM NIC  
   ↓  
Guest OS firewall
```

**Ключові Моменти**

* NSG рівня NIC перекриває NSG рівня підмережі, коли існують обидва.
* Azure застосовує неявні правила (наприклад, заборонити вхідний з Інтернету, якщо явно не дозволено).
* Azure повністю stateful — зворотний трафік тече автоматично.

**Вихідний (Egress) Потік Пакетів — Azure**
```
Guest OS  
   ↓  
VM NIC  
   ↓  
NSG (рівень NIC)  
   ↓  
NSG (рівень підмережі)  
   ↓  
Маршрутизація / NAT  
   ↓  
Internet / VNet peering
```
Azure має більше прихованих поведінок (наприклад, трафік платформи для перевірки здоров'я), ніж AWS/GCP.

### Порівняння Хмар (Резюме)

**GCP**

* Найпростіша модель
* Один шар фаєрволу (VPC firewall)
* Правила на основі ідентичності (теги, сервісні акаунти)
* Маршрутизація відбувається після оцінки фаєрволу

**AWS**

* Два шари фаєрволу (SG + NACL)
* SG: stateful, прив'язаний до NIC
* NACL: stateless, прив'язаний до підмережі
* Найбільш гранулярний, але найбільш складний

**Azure**

* Двошаровий NSG
* Неявні правила
* NSG рівня NIC перекриває рівень підмережі
* Найбільш "enterprise-style" семантика

### Чому Це Важливо

Коли ви усуваєте несправності у хмарній мережі, ви повинні знати:

* Який шар блокує пакет?
* Чи логує це платформа?
* Чи бачить це VM взагалі?
* Фаєрвол stateful чи stateless?
* Чи є неявні правила allow/deny?
* Чи оцінюється маршрутизація до чи після фаєрволу?

Як тільки ви зрозумієте шлях пакету, усунення несправностей хмарного фаєрволу стає детермінованим замість ворожіння.

---

## Мапінг Концепцій `pf` на Хмарні Фаєрволи (і Де Мапінг Ламається)

Якщо ви використовували `pf`, `iptables` або `nftables`, ви вже розумієте основи фільтрації пакетів.
Хмарні фаєрволи повторно використовують багато з цих ідей — але часто способами, які не перекладаються напряму.

### 1. Правила та Якорі → Політики на Основі Ресурсів

У `pf` ви групуєте правила в якорі:
```
anchor "web"
anchor "db"
```

Linux робить щось подібне, використовуючи таблиці та ланцюжки.
```
iptables -t filter -A INPUT ...
```

Хмарні фаєрволи не використовують ланцюжки правил або якорі.
Замість цього вони покладаються на ідентичність ресурсу:

Хмарні фаєрволи не групують правила навколо функцій.
Вони групують їх навколо ресурсів, таких як:

**GCP**

* теги
* сервісні акаунти
* імена інстансів
* скоупи мережі/підмережі

**AWS**

* прикріплення ENI

* членство в security group

**Azure**

* NSG рівня NIC
* NSG рівня підмережі
* Application Security Groups (ASGs)

На практиці:

* pf групує правила за функцією
* хмари групують правила за ресурсом

Цей зсув потужний, але спочатку незвичний.

### 2. Збіг Інтерфейсів → Хмарний Таргетинг

``pf/iptables`` прикріплюють правила до мережевих інтерфейсів:
```
pass in on em0 to port 22
```

**Хмарні фаєрволи повністю від'єднуються від ОС і прив'язуються до:**

* тегів інстансів (GCP)
* сервісних акаунтів (GCP)
* ENI (AWS)
* security groups (AWS)
* NSG рівня NIC або підмережі (Azure)

З точки зору хмари не існує eth0 або em0.
Все абстраговано в ідентичності ресурсів.

### 3. Відстеження Стану → Завжди Увімкнено

У `pf`:
```
pass in proto tcp keep state
```

У `iptables`:
```
iptables .... -m state --state ESTABLISHED,RELATED
```

**У хмарі:**

* GCP: завжди stateful
* AWS Security Groups: завжди stateful
* Azure NSGs: завжди stateful

Ви не можете вимкнути відстеження з'єднань.
Це робить конфігурації коротшими, але також приховує поведінку, яку `pf` показує чітко.

### 4. Default Deny → Непослідовно Між Хмарами

`pf` заохочує класичний патерн:
```
block all
pass tcp to port 22
```

**Хмарні дефолти відрізняються:**

**GCP**

* ingress: deny
* egress: allow

**AWS**

* SG inbound: deny
* SG outbound: allow
* NACLs: allow everything, якщо не змінено

**Azure**

* inbound: deny
* outbound: allow
* існують також правила рівня платформи

Якщо ви звикли до суворої моделі pf "блокувати все", ці дефолти можуть вас здивувати.

### 5. Логування → Flow Logs Замість Логів По Правилах

`pf` може логувати кожне правило:
```
pass in log on em0
```

`iptables` також може логувати по правилах.
```
iptables .... - j LOG
```

**Хмарні фаєрволи використовують flow logs:**

* GCP VPC Flow Logs чудові, але не мають деталізації по правилах.
* AWS Flow Logs показують accept/deny, але не який рядок SG/NACL спрацював.
* Azure NSG Flow Logs часто лагають і вимагають діагностичних дій.

Ви втрачаєте видимість того, яке правило спрацювало на пакет.
Ви бачите лише, чи був трафік дозволений або заборонений.


### 6. NAT та Перенаправлення → Зовсім Інша Поведінка в Хмарах

`pf` дозволяє створювати правила NAT та перенаправлення вручну:
```
nat on em0 from 10.0.0.0/24 to any
rdr on em0 proto tcp to port 80 -> 10.0.0.10 port 8080
```

У хмарах:

> **Cloud NAT — це Шлюз, а не правило.**

* GCP використовує Cloud NAT (рівень VPC)
* AWS використовує NAT Gateway
* Azure використовує NAT Gateway

Ви не визначаєте правила NAT — ви прикріплюєте NAT-пристрої.
Прокидання портів робиться через балансувальники навантаження.
Не через per-host NAT, як pf.
Це одна з областей, де виразність pf не має прямого хмарного еквівалента.


### 7. Порядок Правил → Іноді Важливий, Іноді Ігнорується

`pf` обробляє правила по порядку.
`iptables` обробляє ланцюжки по порядку.

Хмарні платформи поводяться по-різному:

**GCP**

* правила мають пріоритети
* менше число = оцінюється першим

**AWS Security Groups**

* немає пріоритету

* перший збіг allow виграє

* заборони (denies) неявні, а не явні

**AWS NACLs**

* впорядковані, оцінюються рядок за рядком

**Azure NSGs**

* як GCP: пріоритетні номери вирішують порядок

Там, де `pf` явний і детермінований, хмарна поведінка значно варіюється.

### Де `pf` Добре Мапиться на Хмарні Фаєрволи

Багато концепцій `pf` перекладаються добре:

* allow/deny → allow/deny
* stateful правила → дефолтна statefulness
* групування за метою → групування за тегами/SG
* групи інтерфейсів → групи NIC / ASG / сервісні акаунти
* глобальні політики → VPC-wide фаєрволи

### Де Мапінг pf Повністю Ламається

Деякі функції pf просто не існують у хмарній моделі:

* немає rdr або перенаправлення портів (балансувальники навантаження замінюють це)
* немає логування по правилах
* немає специфічних для інтерфейсу правил
* немає тонкої нормалізації пакетів
* немає змішування stateless + stateful правил (крім AWS NACLs)
* немає контролю над поведінкою NAT

Якщо ви звикли до точності pf, хмарна абстракція може здатися грубою.

### Чому Це Важливо

Якщо ви мислите термінами `pf`, хмарні фаєрволи виглядатимуть знайомо.
Якщо ви глибоко розумієте хмарні фаєрволи, `pf` буде відчуватися елегантним і потужним.

Але вони **не взаємозамінні**.

**Хмарні фаєрволи:**

* застосовують політики раніше,
* приховують видимість рівня ОС,
* спрощують деякі рішення,
* і повністю прибирають інші.

Розуміння цієї різниці — це те, що робить усунення несправностей хмарної мережі логічним, а не містичним.

---

## Поширені Помилки Хмарних Фаєрволів (і Чому Усунення несправностей Важчий, Ніж На Unix)

Коли інженери переходять з pf або iptables у хмарні середовища, вони часто припускають, що усунення несправностей з'єднання буде відчуватися так само.
Це не так.

Хмарні фаєрволи створюють нові режими відмов, які просто не існують на "голому залізі".
Вони приховують інформацію, яку ОС зазвичай бачила б, вони застосовують правила раніше на шляху пакету, і вони вводять абстракції, які плутають навіть досвідчених сисадмінів.

Ось найпоширеніші помилки хмарних фаєрволів — і справжні причини, чому їх так важко траблшутити.

### 1. Очікування, Що VM Побачить Заблоковані Пакети

На FreeBSD або Linux, якщо ваш фаєрвол відкидає пакет:

* ви можете побачити це за допомогою tcpdump,
* ви можете залогувати це,
* лічильники збільшуються,
* і ядро знає, що щось сталося.

У хмарі:

**Заблоковані пакети ніколи не досягають VM взагалі.
Гостьова ОС має нульову видимість.**

Це призводить до класичних сценаріїв:

* “Чому моя VM ніколи не отримує SYN-пакети на порт 80?”
* “З'єднання просто висить. Жодних логів.”
* “Це працює локально, але не ззовні.”

Коли хмарний фаєрвол дропає трафік, ОС нічого не бачить, і інструменти, такі як tcpdump, ss або навіть лічильники pf, мовчать.

> Це найбільший зсув мислення.

### 2. Виправлення Не Того Фаєрволу — Хост проти Хмари

Дуже поширена помилка:

Ви відкриваєте порт всередині VM (pf або iptables), але забуваєте відкрити його в хмарному фаєрволі.

Або навпаки:

Ви відкриваєте його в хмарному фаєрволі, але фаєрвол рівня хоста все ще блокує його.

Хмарні фаєрволи не замінюють pf або iptables.
Вони стоять перед ними.

Це призводить до проблеми "Подвійної Чорної Діри":

> Пакет заблокований десь… але жоден шар не каже вам де.

Хмарні фаєрволи рідко логують рішення по правилах, а хостові фаєрволи ніколи не бачать відкинутого трафіку.

### 3. Забування Про Те, Що Хмарні Фаєрволи Спрямовані

На Unix ви часто пишете щось на зразок:
```
pass in on em0 proto tcp to port 22 keep state
```

Це єдине правило визначає як вхідну, так і вихідну поведінку.

Хмарні фаєрволи розділяють ці турботи:

* правила ingress

* правила egress

І вони оцінюються окремо.

Поширена помилка:

> “Я дозволив вхідний 5432, але моя VM не може говорити з базою даних.”

Чому?

Тому що вихідний трафік на порт 5432 був заблокований правилом egress.

У хмарі ви повинні відкривати шлях в обидві сторони, навіть зі stateful фаєрволами.

### 4. Використання IP Замість Ідентичностей

У pf ви часто визначаєте правила на основі адрес:
```
pass in from 10.0.0.5 to any port 22
```

У хмарі цей підхід крихкий.

**VMs:**

* замінюються
* перестворюються
* отримують нові IP
* автомасштабуються
* переміщуються між зонами

Якщо ви покладаєтеся на IP, ваші правила швидко застарівають.

Cloud-native фаєрволінг очікує, що ви будете використовувати:

* теги (GCP)
* security groups (AWS)
* ASG (Azure)
* сервісні акаунти (GCP)

**Правила на основі ідентичності масштабуються.
Правила на основі IP — ні.**

### 5. Ігнорування Неявних Правил

`pf` та `iptables` навмисно явні.

Хмарні фаєрволи включають приховані дефолти:

Приклади

**GCP**

* дозволяє вихідний трафік, якщо явно не заборонено
* блокує весь вхідний за замовчуванням

**AWS**

* SG outbound завжди дозволений, якщо не змінено
* NACLs дозволяють все, якщо не змінено

**Azure**

* має правила рівня платформи, які ви не можете видалити
* NSG мають жорстко задану поведінку deny/allow

Ці неявні правила можуть перекривати ваші очікування і створювати тонкі баги.

### 6. Нерозуміння Багатошарових Фаєрволів (AWS)

AWS використовує:

* Security Groups (stateful, per-ENI)
* NACLs (stateless, per-subnet)

Якщо будь-який шар блокує трафік, ваша VM нічого не побачить.

Усунення несправностей AWS найважчий, коли:

* SG дозволяє це
* але NACL тихо забороняє це

Або навпаки:

* NACL дозволяє це
* SG тихо забороняє це

Ця подвійність потужна, але заплутана для інженерів, які прийшли з pf (де є тільки один фаєрвол).
