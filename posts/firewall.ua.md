# Захист Unix систем: pf проти iptables — Чому FreeBSD досі перемагає.

## Безпека починається на мережевому рівні

Фаєрволи — це місце, де починається ця точність. Вони не яскраві і не модні, але вони визначають невидимі правила довіри: хто може говорити, хто ні, і за яких умов.
Помиліться тут, і все, що вище — від SSH до Kubernetes — успадкує вашу помилку.

У світі Unix існують дві основні філософії контролю: `pf` на стороні BSD та `iptables` (і його наступник, `nftables`) на Linux. Обидва захищають системи, обидва мають коріння, що сягає десятиліть, але вони походять з дуже різних шкіл.

Ця стаття про розуміння цих відмінностей — не в маркетингових термінах, а на практиці.
Як кожна система підходить до безпеки, як конфігурація відображає її філософію, і чому, після всіх цих років, `pf` у FreeBSD все ще відчувається як фаєрвол, розроблений інженерами, а не комітетами.

Тому що хороша безпека — це не про страх.
Це про знання того, що саме зробить ваша система — і чому.

## Unix фаєрволи: Філософія та Еволюція

Unix-системи завжди поділяли просту ідею: все, що рухається через мережу, має бути спостережуваним і контрольованим.
Але те, як цей контроль виражається — і скільки складності повинен прийняти інженер — різко розійшлося між світами BSD та Linux.

### Родовід BSD — Ясність за дизайном

Сім'я BSD завжди віддавала перевагу явній конфігурації над абстракцією.
У ранні дні `ipfw` обробляв фільтрацію пакетів — здібна, але низькорівнева система, яка працювала нормально, коли мережі були малими.
Потім прийшов `pf`, скорочено від Packet Filter, спочатку розроблений для OpenBSD у 2001 році, а згодом прийнятий FreeBSD, NetBSD та іншими.

`pf` був не просто новим фаєрволом. Це був новий спосіб мислення про політику.
Замість управління ланцюжками або таблицями заплутаних правил, він читався як мова — майже англійською за структурою:
```
block in all
pass out quick on egress keep state
pass in on em0 proto tcp from any to any port 22 keep state
```

Ця простота дозволяла легко розмірковувати про те, що зробить система.
Жодних прихованих шарів, жодних демонів, що переписують ваші правила, жодного YAML чи XML на горизонті — просто чистий текстовий файл, `/etc/pf.conf`, який міг описати весь ваш мережевий стан кількома рядками.

Це ідеально відображало мислення BSD: ясність — це безпека.
Коли ви можете прочитати власні правила фаєрволу через шість місяців і все ще розуміти їх, ви з меншою ймовірністю зробите катастрофічні помилки.

### Шлях Linux — Сила через абстракцію

Linux пішов іншим шляхом.
Його ранні фаєрволи, `ipchains` і пізніше `iptables`, були створені для абсолютної гнучкості — дозволяючи адміністраторам будувати майже будь-яку логіку фільтрації, яку можна уявити.
Але гнучкість прийшла ціною читабельності.

Замість речень, iptables працює з твердженнями (statements):

```
iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT
```

Потужно? Безумовно.
Але багатослівно, важко для аудиту і легко помилитися — особливо коли ви починаєте комбінувати десятки ланцюжків і таблиць.

Треба віддати належне, Linux з часом еволюціонував.
Сучасна підсистема `nftables` тепер замінює iptables чистішим синтаксисом і кращою продуктивністю, але концептуальна модель залишається тією ж:
фаєрвол як програмована логіка, а не опис політики.

Це різниця у філософії, яка сягає глибоко.

## Дві школи думки

Хоча обидва фаєрволи служать одній меті — вирішувати, який трафік дозволити або заблокувати — вони виражають цю логіку дуже по-різному.

`pf` (на FreeBSD) використовує декларативний підхід.
Ви описуєте, що ви хочете, щоб сталося, простим способом, заснованим на правилах. Конфігурація читається як документ мережевої політики — чистий, зрозумілий людині і легкий для осмислення навіть через місяці. Він розроблений для передбачуваності та ясності.

`iptables` (і його наступник `nftables`) на Linux слідують процедурній моделі.
Ви будуєте свій фаєрвол крок за кроком — команда за командою — визначаючи ланцюжки, таблиці та збіги. Це потужно і надзвичайно гнучко, але це відчувається більше як програмування двигуна фільтрації, ніж декларування політики. Ця гнучкість приходить ціною складності.

Коротше кажучи:

pf пишеться як політика.

iptables пишеться як код.

Обидва працюють.
Але тільки один можна впевнено дебажити о 2-й ночі без відкритого мануалу поруч.

## `pf` — Шлях FreeBSD

Коли ви відкриваєте систему FreeBSD і дивитеся на `/etc/pf.conf`, з'являється відчуття спокою.
Жодних ланцюжків, жодних таблиць з назвами filter, nat або mangle — просто чиста, декларативна логіка, яка читається більше як заява про політику, ніж як скрипт.

`pf`, скорочено від Packet Filter, — це більше, ніж просто фаєрвол. Це мова мережевої політики, яка надає перевагу точності над хитрістю.
Кожне правило оцінюється зверху вниз, і як тільки ви зрозумієте потік, ви зможете розмірковувати про поведінку вашої системи за секунди — навіть після місяців відсутності.

### Структура конфігурації pf

Базовий файл `/etc/pf.conf` часто слідує простій, логічній схемі:
```sh
# Макроси
ext_if = "em0"
tcp_services = "{ 22, 80, 443 }"

# Опції
set skip on lo
set block-policy drop

# Default Deny (Заборонити за замовчуванням)
block in all
block out all

# Дозволити вихідний та встановлений трафік
pass out quick on $ext_if inet proto { tcp, udp } from any to any keep state
pass in quick on $ext_if proto tcp from any to any port $tcp_services keep state
```

Навіть не знаючи синтаксису pf, ви, ймовірно, можете прочитати це вголос і зрозуміти:

Визначити, що означає "зовнішній" (`em0`).

Вирішити, які порти відкрити (`22, 80, 443`).

Відкидати все за замовчуванням.

Пропускати те, чому ви явно довіряєте.

Ось і все. Жодних прихованих правил, жодного неявного "allow all outbound" — ви контролюєте кожен пакет.

### Stateful за замовчуванням

Одна з найпотужніших функцій pf — це відстеження стану (state tracking).
Коли ви дозволяєте вихідне з'єднання з keep state, pf автоматично дозволяє зворотний трафік.
Немає потреби писати друге правило для шляху відповіді — таблиця станів відстежує активні сесії.

Ви можете перевірити це в будь-який час:
```sh
sudo pfctl -s state
```

Це дає вам видимість у реальному часі кожного з'єднання — джерело, призначення, протокол і тривалість.
Це той вид зворотного зв'язку, який робить налагодження і вивчення поведінки мережі інтуїтивним.

### Таблиці та Макроси — Секретна зброя pf

`pf` також надає таблиці — динамічні списки IP-адрес, на які можна посилатися за іменем у ваших правилах.
Вони ідеальні для блокування великих діапазонів адрес, білих списків мереж або управління живими чорними списками.
```
table <badhosts> persist file "/etc/pf.badhosts"
block in quick from <badhosts> to any
```

Ви можете оновити таблицю без перезавантаження всього фаєрволу:
```
sudo pfctl -t badhosts -T add 203.0.113.5
```

Ця здатність змінювати поведінку в реальному часі без порушення трафіку — це те, з чим навіть багато сучасних Linux-фаєрволів все ще борються.

### Якорі (Anchors) та Модульність

`pf` дозволяє включати секції правил з інших файлів, відомі як якорі.
Це робить складні конфігурації керованими та придатними для повторного використання — ви можете відокремити правила веб-сервера від правил VPN, наприклад, не створюючи окремих наборів правил.
```
anchor "web"
load anchor "web" from "/etc/pf.web.conf"
```

Ця модульність перетворює pf на щось, що масштабується — від домашньої лабораторії до маршрутизатора з багатьма інтерфейсами.

### Ясність, що масштабується

`pf` працює добре, тому що він не намагається бути хитрим.
Він забезпечує філософію, що фаєрвол має бути придатним для аудиту, передбачуваним і самопояснювальним.
Ось чому він залишається дефолтним на OpenBSD, довіреним вибором для користувачів FreeBSD і тихим хребтом незліченних маршрутизаторів та пристроїв безпеки по всьому світу.

Ви можете довіряти `pf` не тому, що він приховує складність — а тому, що він показує її, чітко.

## iptables та nftables — Шлях Linux

Якщо `pf` відчувається як політика, `iptables` відчувається як код.
Він побудований навколо ідеї, що гнучкість — це все, і що якщо дати інженерам достатньо контролю, вони побудують будь-яку логіку, яка їм потрібна.

Ця філософія формувала мережі Linux понад два десятиліття.
Це потужно, модульно і скриптується — але це також означає, що треба тримати в голові більше.
Одна помилка або правило в неправильному ланцюжку може тихо перетворити захищений хост на відкритий.

### Модель `iptables`

`iptables` організовує свою логіку навколо таблиць (типи операцій) та ланцюжків (шляхи виконання).
Кожна таблиця містить ланцюжки, такі як INPUT, OUTPUT та FORWARD, і кожен ланцюжок містить правила, які відповідають пакетам і вирішують їхню долю.

Типова конфігурація може виглядати так:
```sh
# Скинути старі правила
sudo iptables -F

# Політики за замовчуванням
sudo iptables -P INPUT DROP
sudo iptables -P FORWARD DROP
sudo iptables -P OUTPUT ACCEPT

# Дозволити SSH та web
sudo iptables -A INPUT -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT

# Дозволити встановлені відповіді
sudo iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
```

Це явно, гранулярно і надзвичайно потужно.
Але читабельність страждає — навіть коротка конфігурація може займати десятки рядків, а дебагінг стає вправою з відстеження порядку правил через кілька ланцюжків.

Тим не менш, iptables побудував репутацію Linux за гнучкість: NAT, правила mangle, просунуті збіги та визначені користувачем ланцюжки дозволяють адміністраторам тонко налаштовувати поведінку пакетів на кожному етапі.

### Вихід nftables

До 2010-х років мережі Linux потребували очищення.
`iptables`, `ip6tables`, `arptables` та `ebtables` мали окремий синтаксис, бінарники та хуки ядра.
Рішення прийшло у формі `nftables` — уніфікованого фреймворку фаєрволу, введеного в ядрі Linux 3.13.

`nftables` зберігає ту саму концептуальну модель, але вводить простіший, послідовніший синтаксис і центральний набір правил.
Ви визначаєте, що хочете, один раз, і `nftables` обробляє як IPv4, так і IPv6 трафік під капотом.

Приклад еквівалентних правил `nftables`:
```
table inet filter {
  chain input {
    type filter hook input priority 0;
    policy drop;

    ct state established,related accept
    tcp dport { 22, 80, 443 } accept
  }

  chain output {
    type filter hook output priority 0;
    policy accept;
  }
}
```

Це чистіше, більш читабельно і набагато легше експортувати або модифікувати як єдиний блок:
```
sudo nft list ruleset
```

Під низом `nftables` використовує псевдо-VM у ядрі для виконання правил ефективніше, ніж лінійний обхід ланцюжків у iptables.
Приріст продуктивності реальний, особливо для великих або динамічних наборів правил — але ментальна модель залишається процедурною: пакети течуть через послідовність оцінюваних умов, поки одна не співпаде.

### Інструменти, Шари та Абстракції

Гнучкість Linux означає, що рідко існує один правильний спосіб керувати фаєрволом.
Ви можете редагувати `iptables` напряму, використовувати `ufw` (Ubuntu), `firewalld` (RHEL/Fedora) або покладатися на шари мережі контейнерів, які вводять свої власні правила динамічно (Docker, Kubernetes).

Кожна абстракція додає зручності, але також непрозорості.
Легко дійти до точки, де навіть системний адміністратор не може точно сказати, чому конкретний порт відкритий.

Це компроміс:

На FreeBSD ви володієте правилами.

На Linux ви часто володієте результатом, але шлях до нього може бути напрочуд переповненим.

### Сильні та слабкі сторони

Стек фаєрволу Linux залишається неперевершеним за широтою та інтеграцією — він підтримує ізоляцію контейнерів, шейпінг трафіку, відстеження з'єднань та NAT, все в одному фреймворку.
Але ця сама інтеграція може ускладнити підтримку та осмислення в продакшені.

`pf` дає вам впевненість, показуючи точно, що він робить.
`iptables` та `nftables` дають вам можливості — і це ваша робота переконатися, що вони поводяться правильно.

## pf проти iptables: Простота проти Гнучкості (Порівняння в реальному світі)

Давайте вийдемо за межі прикладів з підручника.
Уявіть, що ви захищаєте невеликий публічний сервер — на ньому працює кілька сервісів:

* SSH (22) для адмінського доступу
* HTTP (80) та HTTPS (443) для веб-сайту
* NTP (123) для синхронізації часу

і він повинен блокувати весь вхідний SMTP (25), тому що це не поштовий сервер.

Крім того, ви хочете логування для дропнутих пакетів і rate-limiting для SSH, щоб запобігти brute-force атакам.

Саме тут філософії pf та iptables починають розходитися так, що ви це відчуваєте.

### pf — лаконічний, керований політикою, читабельний
```sh
# /etc/pf.conf
ext_if = "em0"
web_ports = "{ 80, 443 }"
ssh_guard = "{ 22 }"

set block-policy drop
set skip on lo
set loginterface $ext_if

# Default deny
block all

# Allow established sessions
pass in quick on $ext_if proto { tcp, udp } from any to any keep state

# Web services
pass in on $ext_if proto tcp from any to any port $web_ports keep state

# SSH with rate-limit (max 5 connections in 30 seconds)
pass in on $ext_if proto tcp from any to any port $ssh_guard \
    flags S/SA keep state (max-src-conn-rate 5/30, overload <ssh-abuse> flush global)

# Time sync (outgoing only)
pass out on $ext_if proto udp from any to any port 123 keep state

# Block mail explicitly
block in log on $ext_if proto tcp from any to any port 25
```

Читабельно. Декларативно. Самодостатньо.
Кожне правило каже, що ви хочете, а не як цього досягти.

Ви можете перевірити цей файл рядок за рядком і миттєво знати, який трафік дозволено, що логується і що обмежується.
І якщо щось ламається, ви перевіряєте один файл — а не дюжину ланцюжків чи скриптів.

Rate-limiting та динамічні таблиці (<ssh-abuse>) у pf вбудовані.
Ви можете автоматично вносити агресивні IP у чорний список — жодного зовнішнього демона не потрібно.

### iptables — явний, процедурний, шаруватий

Тепер спробуємо виразити ту саму логіку на Linux:
```sh
# Flush and reset
iptables -F
iptables -X
iptables -t nat -F
iptables -t mangle -F

# Default policies
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT

# Allow loopback
iptables -A INPUT -i lo -j ACCEPT

# Allow established/related sessions
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# Web services
iptables -A INPUT -p tcp -m multiport --dports 80,443 -m conntrack \
    --ctstate NEW,ESTABLISHED -j ACCEPT

# SSH with rate limit (requires hashlimit module)
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW \
    -m hashlimit --hashlimit 5/minute --hashlimit-burst 3 \
    --hashlimit-mode srcip --hashlimit-name ssh_guard -j ACCEPT

# NTP (outbound only — allow replies)
iptables -A INPUT -p udp --sport 123 -m conntrack --ctstate ESTABLISHED -j ACCEPT

# Block mail and log
iptables -A INPUT -p tcp --dport 25 -j LOG --log-prefix "SMTP_DROP: "
iptables -A INPUT -p tcp --dport 25 -j DROP
```

Результат: це працює — але ви відчуваєте різницю.

Логіка розкидана по кількох шарах, і кожна маленька зміна означає торкання кількох команд.
Щоб зробити це постійним, вам також потрібно експортувати та імпортувати ваші правила:
```sh
sudo iptables-save > /etc/iptables/rules.v4
```

Навіть досвідчені адміністратори часто покладаються на інструменти-обгортки (`ufw`, `firewalld`, `nft`), тому що ручна підтримка iptables з часом стає рутиною.

### Як відчувається різниця

`pf`:

* відчувається як читання документа з політики безпеки.
* порядок правил та оцінка інтуїтивні.
* легко застосовувати, аудити та ділитися між системами.

`iptables`:

* відчувається як написання міні-програми, що контролює потік пакетів.
* неймовірно потужний, але багатослівний і крихкий.
* одна помилка від того, щоб заблокувати себе.

pf припускає, що ви розумієте свій намір.
`iptables` припускає, що ви побудуєте його самі — пакет за пакетом.

Обидва є інструментами контролю, але pf надає перевагу ясності вираження,
тоді як `iptables` надає перевагу гранулярності контролю.

## Продуктивність, Стабільність та Інтеграція

Продуктивність у фаєрволах — це не просто цифри пакетів на секунду — це про послідовність.
Коли трафік стрибає, правила змінюються або логи ротуються, ви хочете систему, яка залишається передбачуваною.
Саме тут дизайнерські рішення, що стоять за `pf` та `iptables/nftables`, починають мати найбільше значення.

### pf — Створений для передбачуваного навантаження

Packet Filter був розроблений для стабільності під тиском.
Зі свого коріння в OpenBSD, `pf` завжди надавав перевагу детермінізму над динамічними трюками.
Він працює в просторі ядра, використовує модель оцінки правил за один прохід і тримає все відстеження стану в централізованій таблиці, яка є ефективною і легкою для інспекції.

Навіть на скромному обладнанні `pf` може обробляти тисячі активних з'єднань без затримок або втрати пакетів.
Ви можете буквально спостерігати, як він масштабується:

```sh
sudo pfctl -s info
sudo pfctl -s state | wc -l
```

Оскільки правила компілюються один раз і завантажуються атомарно, `pf` уникає часткових перезавантажень або перехідних станів — що може статися в Linux, коли ланцюжки перезастосовуються на завантаженій системі.

Та сама дисципліна дизайну робить `pf` неймовірно стабільним для довготривалих серверів, маршрутизаторів або VPN-шлюзів.
Багато вбудованих мережевих пристроїв — від комерційних фаєрволів до роутерів на базі OpenBSD — покладаються на pf саме тому, що він нудно надійний.

### `iptables` — Гнучка, але Stateful Складність

`iptables` був створений для гнучкості, і ця гнучкість приходить з накладними витратами.
Кожне правило належить до ланцюжка, кожен ланцюжок належить до таблиці, і пакети проходять ці ланцюжки по порядку.
Чим більше правил ви додаєте, тим більше пошуків виконує ядро — лінійно — поки не буде знайдено збіг.

Для малих сетапів різниця незначна.
Для великих або динамічно керованих мереж це може стати помітним, особливо коли правила часто вставляються або видаляються інструментами автоматизації, такими як firewalld, Docker або Kubernetes.

Тим не менш, двигун відстеження з'єднань Linux є надійним — він може ефективно відстежувати мільйони з'єднань, за умови, що ви налаштуєте nf_conntrack_max та пов'язані параметри.
Але тюнінг — це частина роботи.
pf, на відміну від цього, рідко цього потребує.

### nftables — Сучасна золота середина

`nftables` вирішує багато з цих проблем продуктивності.
Замість лінійного обходу правил, він використовує внутрішній двигун байт-коду, який оцінює правила ефективніше і може представляти кілька протоколів (IPv4, IPv6, ARP тощо) в одному уніфікованому наборі правил.

Перезавантаження правил є атомарним і не порушує існуючі з'єднання — нарешті відповідаючи поведінці pf.
Багато в чому `nftables` наближає Linux до простоти, яку користувачі pf мали роками.

Але `nftables` також успадковує найбільший виклик Linux: розростання інтеграції.
Контейнери, інструменти оркестрації та хмарні платформи — всі вони вводять свою власну логіку фаєрволу.
На той час, коли ви виведете список своїх правил, ви можете побачити ланцюжки, що належать Docker, Podman або NetworkManager — кожен з яких керує своєю підмножиною трафіку.

Ця складність ускладнює діагностику продуктивності, навіть коли "сира" пропускна здатність чудова.

### Практична реальність

У повсякденному використанні:

`pf` відчувається стабільним, тому що він таким є — перезавантаження правил атомарні, синтаксис детермінований, а управління станом прозоре.

`iptables` та `nftables` можуть зрівнятися або перевершити пропускну здатність pf у бенчмарках, але їх підтримка в живому, еволюціонуючому середовищі часто вводить людську та процедурну крихкість.

І як знає кожен, хто керував реальними системами:
стабільний фаєрвол, який ніколи вас не дивує, швидший за той, що потребує постійного тюнінгу.

## Інтеграція та Інструментарій

Фаєрволи не живуть в ізоляції.
Вони є частиною системи — підключені до логів, інтерфейсів, агентів моніторингу та інструментів автоматизації.
І хоча і pf, і iptables охороняють пакети, їхня екосистемна інтеграція розповідає дві дуже різні історії.

### `pf` — Інструментарій Інженера

Стек фаєрволу FreeBSD побудований навколо ідеї, що один інструмент повинен робити одну річ добре — і разом вони формують чистий, композитний робочий процес.

``pfctl`` — утиліта управління.
Вона завантажує, очищає та інспектує активний набір правил:
```sh
sudo pfctl -sr        # Показати завантажені правила
sudo pfctl -si        # Показати статистику інтерфейсів
sudo pfctl -ss        # Показати активну таблицю станів
sudo pfctl -nf /etc/pf.conf   # Перевірка конфігурації (Dry-run)
```

Кожна команда дає вам читабельний вивід — не потрібно парсити JSON чи XML.

``pflog`` — вбудоване логування пакетів.
Залоговані пакети йдуть у псевдо-інтерфейс (pflog0), який ви можете моніторити в реальному часі:
```
sudo tcpdump -n -e -ttt -i pflog0
```

Цей єдиний рядок дозволяє вам відстежувати, що робить фаєрвол, пакет за пакетом — розкіш при дебагінгу складних політик.

Інтеграція з rc(8).
`pf` запускається і зупиняється як будь-який інший системний сервіс.
Правила декларуються в `/etc/pf.conf`, а запуск керується декларативно через `/etc/rc.conf`:
```
pf_enable="YES"
pflog_enable="YES"
```

Жодних демонів, що переписують вашу конфігурацію за лаштунками — що означає жодних сюрпризів.

### Розширюваність.
`pf` природно інтегрується з іншими підсистемами BSD: `altq` для шейпінгу трафіку, `carp` для надлишковості, `pfsync` для синхронізації станів між фаєрволами.
Та сама філософія поширюється від одного ноутбука до кластера HA рівня enterprise.

Коротше кажучи, `pf` дає вам прямий контроль з мінімальною кількістю рухомих частин — ідеально для адміністраторів, які віддають перевагу ясності над магією автоматизації.

### `iptables/nftables` — Шари на Шарах

Linux, з іншого боку, знаходиться в серці сучасної інфраструктури — від ноутбуків до гіпермасштабних хмар — і його інструменти фаєрволу еволюціонували відповідно.
Ця еволюція принесла як силу, так і фрагментацію.

Основні інструменти:

`iptables` — легасі CLI простору користувача для управління ланцюжками та таблицями ядра.

`nft` — сучасна заміна, що уніфікує правила IPv4, IPv6, ARP та бріджінгу.

Обидва надають повний контроль, але жоден не є по-справжньому дружнім до користувача.
```
sudo iptables -L -v -n
sudo nft list ruleset
```

Читання цих виводів відчувається більше як читання вихідного коду, ніж конфігураційного файлу.

Інструменти-обгортки:
Щоб спростити адміністрування, дистрибутиви ввели шари абстракції:

`ufw` (Ubuntu): дружній до початківців, декларативний синтаксис.
`firewalld` (RHEL/Fedora): демон на базі D-Bus із зонами та перезавантаженнями під час виконання (runtime reloads).
`iptables-persistent`: зберігає правила для запуску системи.

Кожна абстракція допомагає в одному середовищі — але ускладнює інше.
`ufw` ігнорує `nftables`, `firewalld` динамічно вставляє ланцюжки, а контейнери додають свої власні.

Інтеграція Контейнерів та Хмар:
Docker, Kubernetes та CNI плагіни генерують правила фаєрволу динамічно в `iptables/nftables` для забезпечення мережевих політик.
Хоча ця інтеграція потужна, вона також означає, що ваш набір правил більше не є повністю вашим.
Один контейнер, що поводиться неправильно, може переписати або перевпорядкувати ланцюжки без вашого відома.

### Моніторинг та Логування:
Linux підтримує логування через цілі `LOG` або `NFLOG`, інтегровані з `journalctl` або зовнішніми інструментами.
Це працює — але цьому бракує елегантності `pflog`.
Відстеження пакетів через динамічно вставлені правила вимагає навичок, терпіння і буфера прокрутки, який може розтягнутися на сторінки.

### Два Інструментарії, Два Мислення

`pf` припускає, що ви є мозком системи — він надає інструменти, а не фреймворки.
Linux припускає, що система буде еволюціонувати навколо вас — він надає шари для співіснування та оркестрації.

Мінімалізм `pf` робить його радістю для дебагінгу.
Гнучкість iptables та nftables робить їх незамінними в розподілених системах — але також важчими для повної довіри, тому що занадто багато шарів можуть змінити поведінку до того, як пакети досягнуть ваших правил.

Обидві екосистеми зрілі та здібні.
Вибір не про те, яка з них "краща" — а про те, скільки абстракції ви можете толерувати, перш ніж почнете втрачати видимість.

## Чому FreeBSD Досі Перемагає

Коли ви керуєте системами досить довго, ви розумієте, що безпека — це не про закриття всього підряд — це про контроль складності.
Кожне правило, кожен демон, кожен шар автоматизації додає трохи більше непередбачуваності.
І коли щось ламається о 3-й ночі, передбачуваність — це єдине, що має значення.

Саме тут pf у FreeBSD заробляє свою репутацію.

Справа не в тому, що pf швидший, яскравіший або новіший.
Справа в тому, що pf є зібраним, зрозумілим і послідовним — якості, які масштабуються набагато краще, ніж "сира" продуктивність.

1. Декларативна Простота

`pf` говорить повними думками.
Кожен рядок в `/etc/pf.conf` виражає намір, а не механіку:
```
block in all
pass in on em0 proto tcp to port { 22, 443 } keep state
```

Це не синтаксичний цукор — це філософія.
Ви описуєте політику, а не мікро-менеджите ланцюжки та таблиці.
Коли хтось читає вашу конфігурацію, він бачить, що ви мали на увазі, а не просто як ви це реалізували.
І оскільки правила атомарні та читабельні, відхилення конфігурації (configuration drift) майже відсутній.

2. Передбачувані Операції

Перезавантаження набору правил `pf` не перериває трафік.
Це відбувається атомарно — або нові правила завантажуються успішно, або вони не завантажуються взагалі.
Немає "напівзастосованого" стану фаєрволу, немає невидимих гонок (race conditions).

Коли ви інспектуєте свої правила за допомогою `pfctl -sr`, ви бачите точно те, що працює.
Жодних прихованих ланцюжків від Docker, жодних системних демонів, що переписують політики у фоні.

Ця передбачуваність — золото, коли ваш аптайм — або ваша репутація — залежить від послідовності.

3. Інтеграція Без Заплутування

`pf` чисто інтегрується з рештою екосистеми FreeBSD —
`rc.conf`, `pflog`, `altq`, `carp` та `pfsync` — не потребуючи демона управління або шару плагінів.
Він поважає філософію Unix: малі, композитні інструменти, кожен з яких робить одну роботу добре.

Результат — система, де ви завжди знаєте, де живе конфігурація, як вона застосовується і як відтворити її на іншому хості.
Вам не потрібно "керувати менеджером".

4. Безпека за Дизайном, А Не Реакція

Модель розробки `pf` походить від родоводу OpenBSD — де правильність і безпека є культурними дефолтами, а не думками "після".
Це мислення переноситься на FreeBSD.
Поки Linux безперервно еволюціонує навколо нових фреймворків та абстракцій контейнерів, FreeBSD схильна еволюціонувати всередину — роблячи те, що вже існує, більш надійним.

Це не стагнація. Це зрілість.
Ви отримуєте менше регресій, менше "breaking changes" і більше часу, щоб зосередитися на тому, що насправді має значення: поведінці системи.

5. Фактор Спокою

Коли ви відкриваєте систему FreeBSD через рік, вона поводиться так само, як у день, коли ви її залишили.
Правила `pf` все ще завантажуються так само.
Логи все ще виглядають так само.
У цьому є щось тихо потужне — стабільність, яка заробляє довіру, чим довше ви нею користуєтеся.

Натомість на Linux навіть мінорні оновлення версій можуть змінити те, як взаємодіють `nftables`, `firewalld` або `NetworkManager`.
Ви все ще можете досягти надійності — але це вимагає більше роботи, більше тестування і більше документації.

### Не Про Перемогу — Про Знання "Чому"

pf не "кращий", тому що він від BSD.
Він кращий, тому що він чесний: він показує вам точно, що він робить, без прихованих шарів.
І коли ваша безпека залежить від прозорості, ця чесність варта більше, ніж будь-яка нова фіча.

`pf` у FreeBSD представляє той вид інженерії, що триває — мінімальний, передбачуваний і розроблений для людей, яким потрібно розуміти системи, а не просто конфігурувати їх.

>Зрештою, "FreeBSD досі перемагає" — це не слоган, це тиха заява про надійність.
>Ви не можете автоматизувати довіру. Ви повинні будувати її, один пакет за раз.
