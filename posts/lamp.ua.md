# Побудова Вебу: LAMP проти FAMP — Архетип Інтернету

> **Перш ніж ізолювати, ми повинні обслуговувати.**

У попередній статті ми визначили, чому ми повертаємося до "Старого Стеку". Ми посилили наш сервер, захистили мережу і підготували ґрунт. Тепер настав час будувати двигун.

Незалежно від того, чи керуєте ви масивним кластером WordPress, платформою електронної комерції Magento або кастомним API, базова архітектура залишається беззаперечним королем інтернету: **Трьохрівневий Веб-Стек.**

  * **ОС:** Linux або FreeBSD
  * **Веб-сервер:** Apache (або Nginx)
  * **База даних:** MySQL (або MariaDB)
  * **Мова:** PHP (або Python/Perl)

Це створює відомі абревіатури: **LAMP** та **FAMP**. (Існує також WAMP для Windows, але ми тут будуємо сервери, а не локальні середовища розробки).

У цьому гайді ми не просто запустимо `apt-get install`. Ми розглянемо фундаментальні відмінності в тому, як Linux та FreeBSD підходять до сховища, як вони керують сервісами і як вони підтримують систему з часом.

## 1\. Архітектура Стеку

Перш ніж встановлювати, ми повинні зрозуміти потік.

1.  **Apache** слухає на TCP порті 80/443. Він обробляє з'єднання.
2.  Якщо запит на статичний файл (зображення, HTML), Apache віддає його з диска.
3.  Якщо запит на код (`index.php`), Apache передає його **Інтерпретатору PHP**.
4.  PHP виконує логіку, запитуючи дані у **MySQL**.
5.  MySQL повертає дані, PHP рендерить HTML, і Apache надсилає його назад користувачеві.

У сучасних мікросервісах це можуть бути три різні контейнери. У класичному хостингу це три сервіси, що спілкуються на `localhost`.

## 2\. Встановлення: Пакети проти Портів

Ось де дві операційні системи розходяться у філософії.

### Linux (Debian/Ubuntu): "Швидкий" Шлях

Дистрибутиви Linux надають пріоритет швидкості та зручності. Вони розбивають програмне забезпечення на багато маленьких, попередньо скомпільованих пакетів.

```bash
sudo apt update
sudo apt install apache2 mysql-server php libapache2-mod-php php-mysql
```

*Примітка: Linux автоматично вирішує залежності і часто запускає сервіси за вас негайно.*

### FreeBSD: "Бінарний" Шлях (pkg)

FreeBSD пропонує схожий досвід зі своїм бінарним менеджером пакетів. Він швидкий, чистий і надійний.

```bash
sudo pkg update
sudo pkg install apache24 mysql80-server php82 mod_php82
```

*Примітка: FreeBSD відокремлює сервер Apache (`apache24`) від мовного модуля (`mod_php82`), даючи вам явний контроль над версіями.*

### FreeBSD: Шлях "Архітектора" (Порти)

Це суперсила BSD.
За роки моєї роботи в хостинговій компанії нам часто була потрібна специфічна версія Apache з кастомним модулем, або легка збірка MySQL без вбудованої аналітики. **Порти** дозволяють компілювати програмне забезпечення з вихідного коду за допомогою інтерфейсу з меню.

```bash
# Оновити дерево портів
sudo git clone https://git.FreeBSD.org/ports.git /usr/ports

# Зібрати Apache
cd /usr/ports/www/apache24
sudo make config
```

З'являється синій TUI (Текстовий Інтерфейс Користувача). Ви можете відмітити або зняти відмітки з функцій — увімкнути HTTP/2, вимкнути IPv6, вирізати символи налагодження.

```bash
sudo make install clean
```

**Навіщо це робити?**
Безпека та продуктивність. Якщо ви не встановили функцію, її не можна експлуатувати. У високопродуктивному хостингу відсутність зайвого (bloat) має значення.

## 3\. Великий Розподіл: Сховище та Ієрархія

Це найбільш критична ментальна модель для розуміння. Linux та FreeBSD фундаментально не погоджуються у двох речах: **Як керуються диски** та **Де знаходяться файли**.

### Рівень Сховища: Шари проти Інтеграції

Коли ви встановлюєте веб-сервер, вам потрібно знати, де живуть ваші дані. Якщо `/var/log` заповниться, чи впаде ваша база даних? Відповідь залежить від того, як ви керували своїм сховищем.

#### Linux: Шаруватий Підхід (LVM)

Linux слідує "Філософії Unix" малих інструментів, з'єднаних разом. Щоб отримати гнучке сховище, ми зазвичай використовуємо **LVM (Logical Volume Manager)**. Він знаходиться між вашим фізичним диском та вашою файловою системою.

1.  **Physical Volume (PV):** Фактичний диск або розділ (`/dev/sda1`).
2.  **Volume Group (VG):** Пул сховища, створений шляхом об'єднання PV.
3.  **Logical Volume (LV):** Віртуальний "шматок", який ви вирізаєте з групи.
4.  **Filesystem:** Форматуєте LV у `ext4` або `xfs`.

**Чому це важливо:**
Якщо ваша база даних виростає занадто великою, вам не потрібно купувати більший диск і копіювати все. Ви просто підключаєте новий диск, додаєте його до Volume Group і розширюєте Logical Volume на льоту.

> Свого часу ми нарізали диски за допомогою LVM для віртуальних серверів. Але згодом перешли на ZFS 

#### FreeBSD: Інтегрований Підхід (ZFS)

FreeBSD (і сучасні системи загалом) сильно покладається на **ZFS**.
ZFS — це Volume Manager, RAID контролер та Файлова система, згорнуті в одне ціле. У неї немає шарів; вона має знання про весь стек.

Замість розділів або томів, ZFS використовує **Datasets** (Набори даних).
У стандартному стеку FAMP ваша структура часто виглядає так автоматично:

  * `zroot/ROOT/default` (Базова ОС)
  * `zroot/usr/local` (Ваші встановлені додатки)
  * `zroot/var/log` (Ваші логи)
  * `zroot/var/db/mysql` (Ваша база даних)
  * `zroot/ust/home/d3ep0ps` (Ваша домашня директорія)

**Сила Datasets:**
Оскільки ZFS керує всім цим, ви можете застосовувати політики для кожного набору даних миттєво:

  * **Стиснення:** Увімкніть `lz4` стиснення тільки для `/var/log` (логи стискаються чудово).
  * **Квоти:** Встановіть жорстку квоту на `/zroot/var/db/mysql`, щоб база даних, що вийшла з-під контролю, не могла заповнити кореневий диск і покласти ОС.
  * **Снапшоти:** Зробіть снапшот *тільки* набору даних бази даних перед оновленням. Якщо воно зламається, `zfs rollback` миттєвий.

**Примітка про "Slices":**
Якщо ви подивитеся на старішу документацію FreeBSD (або базові дискові пристрої), ви можете побачити терміни на кшталт `ada0s1` (Slice 1) та `ada0p2` (Partition 2).

  * **Slices** були способом FreeBSD ділити старі MBR диски.
  * **Partitions** були підрозділами всередині слайсу.
    Сьогодні, з GPT (GUID Partition Table) та ZFS, ми здебільшого ставимося до диска як до сирого пулу сховища, подібно до того, як LVM ставиться до Physical Volume.

### Ієрархія Файлової Системи

Через цю філософію розділення, FreeBSD забезпечує сувору межу між "Базовою Системою" та "Userland".

**Linux (Блендер)**

  * **Конфіги:** `/etc/apache2/`, `/etc/mysql/`
  * **Web Root:** `/var/www/html/`
  * **Дані MySQL:** `/var/lib/mysql`
  * **Логи:** `/var/log/apache2/`
  * *Реальність:* Конфіги ОС (мережа, ssh) та конфіги Додатків (Apache, MySQL) змішані в `/etc`.

**FreeBSD (Розділення)**

  * **Конфіги Базової ОС:** `/etc/` (SSH, PF, облікові записи користувачів)
  * **Конфіги Встановлених Додатків:** `/usr/local/etc/`
      * Apache: `/usr/local/etc/apache24/httpd.conf`
      * PHP: `/usr/local/etc/php.ini`
      * MySQL: `/usr/local/etc/mysql/my.cnf`
  * **Web Root:** `/usr/local/www/apache24/data/`
  * **Дані MySQL:** `/var/db/mysql`
  * **Логи:** `/var/log/httpd-access.log`

**Філософія:** Ви теоретично могли б видалити весь набір даних `/usr/local`, і ваша система FreeBSD все одно завантажилася б, підключилася до мережі та дозволила вхід через SSH. Ваш рівень додатків ніколи не забруднює рівень ядра.

## 4\. З'єднуємо Все Разом: Управління Сервісами (Війни Init)

Встановлення програмного забезпечення розміщує бінарні файли на диску, але **Init System** — це те, що вдихає в них життя. Це перший процес, який запускає ядро (PID 1), і він відповідає за запуск всього іншого.

Тут Linux та FreeBSD займають два різні світи: **Революція проти Еволюції.**

### Linux: Від SysV до systemd (Революція)

Десятиліттями Linux використовував **System V Init (SysV)**. Якщо ви ветеран-адмін, ви пам'ятаєте це добре.

  * **Скрипти:** Сервіси жили в `/etc/init.d/` як shell-скрипти.
  * **Runlevels:** ОС мала стани, звані "Runlevels" (0–6).
      * `0`: Зупинка (Halt)
      * `3`: Багатокористувацький (Серверний режим)
      * `5`: Графічний (Десктопний режим)
      * `6`: Перезавантаження
  * **Проблема:** Це було повільно. Сервіси запускалися один за одним (послідовно). Якщо мережа зависала, все, що за нею, чекало.

**Вихід systemd (Сучасний Стандарт)**
Близько 2010–2015 років більшість дистрибутивів Linux перейшли на **systemd**. Це був масивний зсув парадигми.

  * **Паралелізм:** Він запускає сервіси одночасно.
  * **Цілі (Targets):** "Runlevels" були замінені на "Targets" (`multi-user.target`).
  * **Бінарні Логи:** Логи перемістилися з текстових файлів у бінарний формат (`journalctl`).

```bash
# Старий Шлях (SysV)
service apache2 start
chkconfig apache2 on

# Новий Шлях (systemd)
systemctl enable apache2
systemctl start apache2
```

### FreeBSD: Система rc.d (Еволюція)

FreeBSD подивилася на хаос Init систем і вирішила **еволюціонувати**, а не замінювати. Вона використовує систему **rc.d**. Вона все ще базується на скриптах (як SysV), але вона вирішила проблему серіалізації розумно.

  * **На Основі Залежностей:** Замість використання чисел (`S01`, `S02`), щоб вгадати порядок, кожен скрипт запуску FreeBSD містить метадані (`REQUIRE: NETWORKING`, `BEFORE: DAEMON`). Система розраховує правильний порядок при кожному завантаженні.
  * **Централізований Конфіг (`rc.conf`):** Linux розкидає "увімкнені" сервіси. FreeBSD має єдине джерело істини: `/etc/rc.conf`.

**Як Ми Це Налаштовуємо:**

**На FreeBSD (rc.conf):**
Ми редагуємо реєстр істини. Ви можете зробити це за допомогою `vi /etc/rc.conf` або використати помічника:

```bash
sudo sysrc apache24_enable="YES"
sudo sysrc mysql_enable="YES"
sudo service apache24 start
```

*Примітка: На FreeBSD вам часто потрібно виконати один ручний крок для PHP. Ви повинні відредагувати `/usr/local/etc/apache24/Includes/php.conf` (або створити його), щоб сказати Apache обробляти файли `.php`.*

## 5\. База Даних: Первинна Безпека

З коробки MySQL часто є небезпечним (порожній пароль root, дозволені анонімні користувачі). Незалежно від ОС, ви повинні запустити скрипт безпеки.

```bash
sudo mysql_secure_installation
```

Відповідайте **Так** на:

  * Встановити пароль root? (Зробіть його сильним)
  * Видалити анонімних користувачів?
  * Заборонити віддалений вхід root? (Критично)
  * Видалити тестову базу даних?
  * Перезавантажити таблиці привілеїв?

**Pro Tip:** Ніколи не змушуйте ваш додаток підключатися як `root`.

```sql
CREATE DATABASE d3ep0ps_web;
CREATE USER 'web_user'@'localhost' IDENTIFIED BY 'StrongPassword';
GRANT ALL PRIVILEGES ON d3ep0ps_web.* TO 'web_user'@'localhost';
FLUSH PRIVILEGES;
```

## 6\. Тест: "Hello World"

Давайте перевіримо, чи стек спілкується. Створіть файл у вашому web root (`/var/www/html` на Linux, `/usr/local/www/apache24/data` на FreeBSD).

`index.php`:

```php
<?php
phpinfo();
?>
```

Відкрийте браузер і вкажіть IP-адресу вашого сервера: `http://192.0.2.10`.
Ви повинні побачити фіолетову інформаційну сторінку PHP.

## 7\. Навичка Виживання: Гігієна Сховища (Логи, Inodes та Розділи)

У моїй практиці, причиною падіння серверів №1 були не хакери — це були **повні диски**. Але "повний" не завжди означає те, що ви думаєте.

### Прихований Вбивця: Вичерпання Inode

Більшість людей перевіряють місце на диску за допомогою `df -h`. Він каже, що у вас 50GB вільно.
Але коли ви намагаєтеся записати файл, ви отримуєте `No space left on device`. Чому?

**У вас закінчилися Inodes.**
Кожен файл вимагає **inode** (індексний вузол) для зберігання своїх метаданих. Стандартні файлові системи створюють фіксовану кількість inodes при форматуванні.

**Пастка Хостингу:**
Неправильно налаштований PHP додаток починає створювати файли сесій у `/tmp` або `/var/lib/php/sessions`. Він створює один маленький 4KB файл для кожного відвідувача.

  * **Результат:** У вас 1 мільйон крихітних файлів. Ваш 1TB диск заповнений даними лише на 1%, але на 100% заповнений inodes.
  * **Перевірка:** Запустіть `df -i`. Якщо там 100%, ви припливли.

### Захисне Розбиття Диска (Не монтуйте / на все)

Найгірша схема розбиття для сервера — це **один гігантський кореневий (`/`) розділ**.
Якщо користувач завантажить занадто багато файлів у `/home`, або логи Apache заспамлять `/var`, вони заповнять **кореневу файлову систему**.
Коли `/` заповнюється, ваша оболонка не може створювати тимчасові файли, ви не можете натиснути `Tab` для автодоповнення, і SSH може навіть "відмовити" вам.

**Виправлення:** Відокремте змінні дані від ОС.

#### Стратегія Linux (LVM)

Ми використовуємо LVM для створення окремих логічних томів для небезпечних директорій:

  * `/` (Root OS - Тримайте це чистим!)
  * `/var` (Логи та Бази даних - Найбільш імовірні до вибуху)
  * `/tmp` (Тимчасові файли - Вбивця Inode)
  * `/home` (Дані користувачів)

Якщо `/var` заповниться, MySQL зупиниться, **але ОС продовжить працювати.** Ви все ще зможете зайти через SSH, щоб виправити це.

#### Стратегія FreeBSD (ZFS Datasets)

FreeBSD вирішує це автоматично за допомогою наборів даних ZFS.

  * `zroot/tmp`
  * `zroot/var`
  * `zroot/var/log`

Ви навіть можете встановити **Квоту** на `zroot/tmp`.

```bash
# Обмежити /tmp до 1GB, щоб жоден скрипт не міг покласти сервер
sudo zfs set quota=1G zroot/tmp
```

### Ротація Логів

Нарешті, ми повинні очищати логи, які споживають це місце.

**Linux (`logrotate`)**
Налаштовується в `/etc/logrotate.d/apache2`. Використовує `cron` для перейменування, стиснення та видалення старих логів щодня.

**FreeBSD (`newsyslog`)**
Налаштовується в `/etc/newsyslog.conf`.

```text
# logfilename          [owner:group]    mode count size when  flags [/pid_file] [sig_num]
/var/log/httpd-access.log  root:wheel    644  7     * @T00  J     /var/run/httpd.pid 30
```

*Переклад:* "Зберігати 7 стиснутих копій, ротувати опівночі та надсилати сигнал Apache, щоб звільнити дескриптор файлу."

## Відсутня Ланка

Тепер у нас працює надійний стек Web, App та Database.
Але прямо зараз ви можете відвідати його лише ввівши IP-адресу.

Щоб змусити `d3ep0ps.com` вказувати на цей сервер, нам потрібен DNS.
І щоб хостити ваш *власний* DNS на цьому сервері (створюючи `ns1.d3ep0ps.com`), ми стикаємося з логічною головоломкою під назвою **Парадокс Bootstrap**.

У наступній статті ми розберемо **BIND** та **Glue Records**, щоб дати нашому серверу ім'я.
